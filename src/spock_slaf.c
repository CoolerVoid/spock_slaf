/* Generated by re2c 1.3 on Fri Apr 29 20:12:11 2022 */
#line 1 "spock_slaf.c"
#line 1 "spock_slaf.c"
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <stdbool.h>
#include <fcntl.h>
#include <dlfcn.h>
#include <unistd.h>
#include <netinet/in.h>
#include <sys/uio.h>
#include <arpa/inet.h>
#include <assert.h>
#include <time.h>
#include <errno.h>

// colors macro
#define RED "\033[22;31m"
#define YELLOW "\033[01;33m"
#define CYAN "\033[22;36m"
#define GREEN "\033[22;32m"
#define LAST "\033[0m"

// anomalys log file
#define SPOCK_LOG "spock_agressors.log"
// DFA taint analysis rank to match
#define SPOCK_SCORE 4
 
// set zero to stop DEBUG mode
#define SPOCK_BUGVIEW  1
#define SPOCK_DEBUG(x, s...) do { \
 if (!SPOCK_BUGVIEW) { break; } \
 time_t t = time(NULL); \
 char *d = ctime(&t); \
 fprintf(stderr, "\n--- SPOCK DEBUG-START ---\n\n %.*s %s[%d] %s(): \n", \
 (int)strlen(d) - 1, d, __FILE__, \
 __LINE__, __FUNCTION__); \
 fprintf(stderr, x, ## s); \
 fprintf(stderr,"\n\n--- DEBUG-END ---\n"); \
} while (0);
// detect only HTTP anomalys, if set to zero is can be util for AMQ, zeroMQ, gRPC, SMTP, IMAP...
#define SPOCK_ONLY_HTTP 0

// hook rites
#define _CONSTRUCTOR __attribute__((constructor))
#define _DESTRUCTOR __attribute__ ((destructor))
#define SPOCK_LOAD_CALL(var, name) \
	do {\
		const char *err; \
		(var) = dlsym(RTLD_NEXT, (name)); \
		if ((err = dlerror()) != NULL) { \
			fprintf(stderr, "dlsym %s: %s\n", (name), err); \
			exit(EXIT_FAILURE); \
		} \
	} while(0)



struct spock_hook_ctx {
	int (*SSL_read)(void *ssl, void *buf, int num);
	int (*SSL_get_rfd)(void *ssl);
	int (*SSL_get_wfd)(void *ssl);
};

enum {
  SQLI,XSS,PATHTRAVERSAL,COUNTER,FILTER_END
};

static struct spock_hook_ctx spock_ctx;

void 
spock_write_log (char *str)
{
	int fd = open(SPOCK_LOG, O_CREAT | O_WRONLY | O_APPEND, 0760 ); 
	FILE *arq=NULL;

	
		if (-1 != fd) 
		{

			arq = fdopen(fd, "ax");

				if (arq == NULL) 
				{
					SPOCK_DEBUG("error in filename %s  to open() file:  %s",SPOCK_LOG,strerror(errno));		
				    exit(0);
				}

			fprintf(arq,"%s\n",str); 

				if (fclose(arq) == EOF)
				{
					SPOCK_DEBUG("error in Write() file %s",SPOCK_LOG);
					exit(0);
				}
		} else {

				if (close(fd) == -1) 
				{
					
					SPOCK_DEBUG("error in filename %s  to open() file:  %s",SPOCK_LOG,strerror(errno));		
					exit(0);
				}
		}

	arq=NULL; 

}

volatile void *
spock_burn_mem(volatile void *dst, int c, size_t len) 
{
	volatile char *buf;
   
		for (buf = (volatile char *)dst;  len;  buf[--len] = c);

	return dst;
}

//generated DFA... flex+bison etc...
int 
spock_dfa_filter(char** p, char** lex)
{
    char* marker;

    for (;;) {
    *lex = *p;
    
#line 132 "<stdout>"
	{
		char yych;
		yych = (char)**p;
		switch (yych) {
		case '\n':	goto yy4;
		case '*':
		case '.':
		case '>':	goto yy6;
		case 'a':	goto yy7;
		case 'd':	goto yy8;
		case 'e':	goto yy9;
		case 'f':	goto yy10;
		case 'i':	goto yy11;
		case 'j':	goto yy12;
		case 'm':	goto yy13;
		case 'o':	goto yy14;
		case 'p':	goto yy15;
		case 's':	goto yy16;
		case 'u':	goto yy17;
		case 'v':	goto yy18;
		case 'w':	goto yy19;
		default:	goto yy2;
		}
yy2:
		++*p;
yy3:
#line 139 "spock_slaf.c"
		{ continue; }
#line 161 "<stdout>"
yy4:
		++*p;
#line 138 "spock_slaf.c"
		{ return FILTER_END; }
#line 166 "<stdout>"
yy6:
		yych = (char)*(marker = ++*p);
		switch (yych) {
		case '*':
		case '.':
		case '>':
		case 'a':
		case 'd':
		case 'e':
		case 'f':
		case 'i':
		case 'j':
		case 'm':
		case 'o':
		case 'p':
		case 's':
		case 'u':
		case 'v':
		case 'w':	goto yy21;
		default:	goto yy3;
		}
yy7:
		yych = (char)*(marker = ++*p);
		switch (yych) {
		case 'l':	goto yy36;
		default:	goto yy3;
		}
yy8:
		yych = (char)*(marker = ++*p);
		switch (yych) {
		case 'e':	goto yy37;
		case 'o':	goto yy38;
		case 'r':	goto yy39;
		default:	goto yy3;
		}
yy9:
		yych = (char)*(marker = ++*p);
		switch (yych) {
		case 'v':	goto yy40;
		case 'x':	goto yy41;
		default:	goto yy3;
		}
yy10:
		yych = (char)*(marker = ++*p);
		switch (yych) {
		case 'r':	goto yy42;
		default:	goto yy3;
		}
yy11:
		yych = (char)*(marker = ++*p);
		switch (yych) {
		case 'f':	goto yy43;
		case 'n':	goto yy44;
		default:	goto yy3;
		}
yy12:
		yych = (char)*(marker = ++*p);
		switch (yych) {
		case 'a':	goto yy45;
		default:	goto yy3;
		}
yy13:
		yych = (char)*(marker = ++*p);
		switch (yych) {
		case 'a':	goto yy46;
		default:	goto yy3;
		}
yy14:
		yych = (char)*(marker = ++*p);
		switch (yych) {
		case 'n':	goto yy47;
		default:	goto yy3;
		}
yy15:
		yych = (char)*(marker = ++*p);
		switch (yych) {
		case 'a':	goto yy48;
		default:	goto yy3;
		}
yy16:
		yych = (char)*(marker = ++*p);
		switch (yych) {
		case 'c':	goto yy49;
		case 'e':	goto yy50;
		case 'h':	goto yy51;
		case 'l':	goto yy52;
		default:	goto yy3;
		}
yy17:
		yych = (char)*(marker = ++*p);
		switch (yych) {
		case 'n':	goto yy53;
		default:	goto yy3;
		}
yy18:
		yych = (char)*(marker = ++*p);
		switch (yych) {
		case 'e':	goto yy54;
		default:	goto yy3;
		}
yy19:
		yych = (char)*(marker = ++*p);
		switch (yych) {
		case 'h':	goto yy55;
		default:	goto yy3;
		}
yy20:
		yych = (char)*++*p;
yy21:
		switch (yych) {
		case '*':
		case '.':
		case '>':	goto yy20;
		case 'a':	goto yy23;
		case 'd':	goto yy24;
		case 'e':	goto yy25;
		case 'f':	goto yy26;
		case 'i':	goto yy27;
		case 'j':	goto yy28;
		case 'm':	goto yy29;
		case 'o':	goto yy30;
		case 'p':	goto yy31;
		case 's':	goto yy32;
		case 'u':	goto yy33;
		case 'v':	goto yy34;
		case 'w':	goto yy35;
		default:	goto yy22;
		}
yy22:
		*p = marker;
		goto yy3;
yy23:
		yych = (char)*++*p;
		switch (yych) {
		case 'l':	goto yy36;
		default:	goto yy22;
		}
yy24:
		yych = (char)*++*p;
		switch (yych) {
		case 'e':	goto yy37;
		case 'o':	goto yy38;
		case 'r':	goto yy39;
		default:	goto yy22;
		}
yy25:
		yych = (char)*++*p;
		switch (yych) {
		case 'v':	goto yy40;
		case 'x':	goto yy41;
		default:	goto yy22;
		}
yy26:
		yych = (char)*++*p;
		switch (yych) {
		case 'r':	goto yy42;
		default:	goto yy22;
		}
yy27:
		yych = (char)*++*p;
		switch (yych) {
		case 'f':	goto yy43;
		case 'n':	goto yy44;
		default:	goto yy22;
		}
yy28:
		yych = (char)*++*p;
		switch (yych) {
		case 'a':	goto yy45;
		default:	goto yy22;
		}
yy29:
		yych = (char)*++*p;
		switch (yych) {
		case 'a':	goto yy46;
		default:	goto yy22;
		}
yy30:
		yych = (char)*++*p;
		switch (yych) {
		case 'n':	goto yy47;
		default:	goto yy22;
		}
yy31:
		yych = (char)*++*p;
		switch (yych) {
		case 'a':	goto yy48;
		default:	goto yy22;
		}
yy32:
		yych = (char)*++*p;
		switch (yych) {
		case 'c':	goto yy49;
		case 'e':	goto yy50;
		case 'h':	goto yy51;
		case 'l':	goto yy52;
		default:	goto yy22;
		}
yy33:
		yych = (char)*++*p;
		switch (yych) {
		case 'n':	goto yy53;
		default:	goto yy22;
		}
yy34:
		yych = (char)*++*p;
		switch (yych) {
		case 'e':	goto yy54;
		default:	goto yy22;
		}
yy35:
		yych = (char)*++*p;
		switch (yych) {
		case 'h':	goto yy55;
		default:	goto yy22;
		}
yy36:
		yych = (char)*++*p;
		switch (yych) {
		case 'e':	goto yy56;
		default:	goto yy22;
		}
yy37:
		yych = (char)*++*p;
		switch (yych) {
		case 'l':	goto yy57;
		default:	goto yy22;
		}
yy38:
		yych = (char)*++*p;
		switch (yych) {
		case 'c':	goto yy58;
		default:	goto yy22;
		}
yy39:
		yych = (char)*++*p;
		switch (yych) {
		case 'o':	goto yy59;
		default:	goto yy22;
		}
yy40:
		yych = (char)*++*p;
		switch (yych) {
		case 'a':	goto yy60;
		default:	goto yy22;
		}
yy41:
		yych = (char)*++*p;
		switch (yych) {
		case 'p':	goto yy61;
		default:	goto yy22;
		}
yy42:
		yych = (char)*++*p;
		switch (yych) {
		case 'o':	goto yy62;
		default:	goto yy22;
		}
yy43:
		yych = (char)*++*p;
		switch (yych) {
		case 'r':	goto yy63;
		default:	goto yy22;
		}
yy44:
		yych = (char)*++*p;
		switch (yych) {
		case 's':	goto yy64;
		default:	goto yy22;
		}
yy45:
		yych = (char)*++*p;
		switch (yych) {
		case 'v':	goto yy65;
		default:	goto yy22;
		}
yy46:
		yych = (char)*++*p;
		switch (yych) {
		case 'p':	goto yy66;
		case 't':	goto yy67;
		default:	goto yy22;
		}
yy47:
		yych = (char)*++*p;
		switch (yych) {
		case 'c':	goto yy68;
		case 'e':	goto yy69;
		case 'f':	goto yy70;
		case 'l':	goto yy71;
		case 'm':	goto yy72;
		case 'p':	goto yy73;
		case 's':	goto yy74;
		default:	goto yy22;
		}
yy48:
		yych = (char)*++*p;
		switch (yych) {
		case 's':	goto yy75;
		default:	goto yy22;
		}
yy49:
		yych = (char)*++*p;
		switch (yych) {
		case 'r':	goto yy76;
		default:	goto yy22;
		}
yy50:
		yych = (char)*++*p;
		switch (yych) {
		case 'l':	goto yy77;
		default:	goto yy22;
		}
yy51:
		yych = (char)*++*p;
		switch (yych) {
		case 'a':	goto yy78;
		default:	goto yy22;
		}
yy52:
		yych = (char)*++*p;
		switch (yych) {
		case 'e':	goto yy79;
		default:	goto yy22;
		}
yy53:
		yych = (char)*++*p;
		switch (yych) {
		case 'i':	goto yy80;
		default:	goto yy22;
		}
yy54:
		yych = (char)*++*p;
		switch (yych) {
		case 'r':	goto yy81;
		default:	goto yy22;
		}
yy55:
		yych = (char)*++*p;
		switch (yych) {
		case 'e':	goto yy82;
		default:	goto yy22;
		}
yy56:
		yych = (char)*++*p;
		switch (yych) {
		case 'r':	goto yy83;
		default:	goto yy22;
		}
yy57:
		yych = (char)*++*p;
		switch (yych) {
		case 'e':	goto yy84;
		default:	goto yy22;
		}
yy58:
		yych = (char)*++*p;
		switch (yych) {
		case 'u':	goto yy85;
		default:	goto yy22;
		}
yy59:
		yych = (char)*++*p;
		switch (yych) {
		case 'p':	goto yy86;
		default:	goto yy22;
		}
yy60:
		yych = (char)*++*p;
		switch (yych) {
		case 'l':	goto yy89;
		default:	goto yy22;
		}
yy61:
		yych = (char)*++*p;
		switch (yych) {
		case 'r':	goto yy92;
		default:	goto yy22;
		}
yy62:
		yych = (char)*++*p;
		switch (yych) {
		case 'm':	goto yy93;
		default:	goto yy22;
		}
yy63:
		yych = (char)*++*p;
		switch (yych) {
		case 'a':	goto yy94;
		default:	goto yy22;
		}
yy64:
		yych = (char)*++*p;
		switch (yych) {
		case 'e':	goto yy95;
		default:	goto yy22;
		}
yy65:
		yych = (char)*++*p;
		switch (yych) {
		case 'a':	goto yy96;
		default:	goto yy22;
		}
yy66:
		yych = (char)*++*p;
		switch (yych) {
		case 'R':	goto yy97;
		default:	goto yy22;
		}
yy67:
		yych = (char)*++*p;
		switch (yych) {
		case 'c':	goto yy98;
		default:	goto yy22;
		}
yy68:
		yych = (char)*++*p;
		switch (yych) {
		case 'l':	goto yy99;
		default:	goto yy22;
		}
yy69:
		yych = (char)*++*p;
		switch (yych) {
		case 'r':	goto yy100;
		default:	goto yy22;
		}
yy70:
		yych = (char)*++*p;
		switch (yych) {
		case 'i':	goto yy101;
		default:	goto yy22;
		}
yy71:
		yych = (char)*++*p;
		switch (yych) {
		case 'o':	goto yy102;
		default:	goto yy22;
		}
yy72:
		yych = (char)*++*p;
		switch (yych) {
		case 'o':	goto yy103;
		default:	goto yy22;
		}
yy73:
		yych = (char)*++*p;
		switch (yych) {
		case 'a':	goto yy104;
		case 'r':	goto yy105;
		default:	goto yy22;
		}
yy74:
		yych = (char)*++*p;
		switch (yych) {
		case 't':	goto yy106;
		default:	goto yy22;
		}
yy75:
		yych = (char)*++*p;
		switch (yych) {
		case 's':	goto yy107;
		default:	goto yy22;
		}
yy76:
		yych = (char)*++*p;
		switch (yych) {
		case 'i':	goto yy108;
		default:	goto yy22;
		}
yy77:
		yych = (char)*++*p;
		switch (yych) {
		case 'e':	goto yy109;
		default:	goto yy22;
		}
yy78:
		yych = (char)*++*p;
		switch (yych) {
		case 'd':	goto yy110;
		default:	goto yy22;
		}
yy79:
		yych = (char)*++*p;
		switch (yych) {
		case 'e':	goto yy59;
		default:	goto yy22;
		}
yy80:
		yych = (char)*++*p;
		switch (yych) {
		case 'o':	goto yy111;
		default:	goto yy22;
		}
yy81:
		yych = (char)*++*p;
		switch (yych) {
		case 's':	goto yy53;
		default:	goto yy22;
		}
yy82:
		yych = (char)*++*p;
		switch (yych) {
		case 'r':	goto yy112;
		default:	goto yy22;
		}
yy83:
		yych = (char)*++*p;
		switch (yych) {
		case 't':	goto yy89;
		default:	goto yy22;
		}
yy84:
		yych = (char)*++*p;
		switch (yych) {
		case 't':	goto yy112;
		default:	goto yy22;
		}
yy85:
		yych = (char)*++*p;
		switch (yych) {
		case 'm':	goto yy113;
		default:	goto yy22;
		}
yy86:
		yych = (char)*++*p;
		switch (yych) {
		case '\n':	goto yy88;
		default:	goto yy86;
		}
yy88:
#line 135 "spock_slaf.c"
		{ return SQLI; }
#line 700 "<stdout>"
yy89:
		yych = (char)*++*p;
		switch (yych) {
		case '\n':	goto yy91;
		default:	goto yy89;
		}
yy91:
#line 136 "spock_slaf.c"
		{ return XSS; }
#line 710 "<stdout>"
yy92:
		yych = (char)*++*p;
		switch (yych) {
		case 'e':	goto yy114;
		default:	goto yy22;
		}
yy93:
		yych = (char)*++*p;
		switch (yych) {
		case 'C':	goto yy115;
		default:	goto yy22;
		}
yy94:
		yych = (char)*++*p;
		switch (yych) {
		case 'm':	goto yy116;
		default:	goto yy22;
		}
yy95:
		yych = (char)*++*p;
		switch (yych) {
		case 'r':	goto yy117;
		default:	goto yy22;
		}
yy96:
		yych = (char)*++*p;
		switch (yych) {
		case 's':	goto yy118;
		default:	goto yy22;
		}
yy97:
		yych = (char)*++*p;
		switch (yych) {
		case 'e':	goto yy119;
		default:	goto yy22;
		}
yy98:
		yych = (char)*++*p;
		switch (yych) {
		case 'h':	goto yy86;
		default:	goto yy22;
		}
yy99:
		yych = (char)*++*p;
		switch (yych) {
		case 'i':	goto yy120;
		default:	goto yy22;
		}
yy100:
		yych = (char)*++*p;
		switch (yych) {
		case 'r':	goto yy121;
		default:	goto yy22;
		}
yy101:
		yych = (char)*++*p;
		switch (yych) {
		case 'n':	goto yy122;
		default:	goto yy22;
		}
yy102:
		yych = (char)*++*p;
		switch (yych) {
		case 'a':	goto yy123;
		default:	goto yy22;
		}
yy103:
		yych = (char)*++*p;
		switch (yych) {
		case 'u':	goto yy124;
		default:	goto yy22;
		}
yy104:
		yych = (char)*++*p;
		switch (yych) {
		case 'g':	goto yy125;
		default:	goto yy22;
		}
yy105:
		yych = (char)*++*p;
		switch (yych) {
		case 'o':	goto yy126;
		default:	goto yy22;
		}
yy106:
		yych = (char)*++*p;
		switch (yych) {
		case 'a':	goto yy56;
		default:	goto yy22;
		}
yy107:
		yych = (char)*++*p;
		switch (yych) {
		case 'w':	goto yy127;
		default:	goto yy22;
		}
yy108:
		yych = (char)*++*p;
		switch (yych) {
		case 'p':	goto yy83;
		default:	goto yy22;
		}
yy109:
		yych = (char)*++*p;
		switch (yych) {
		case 'c':	goto yy117;
		default:	goto yy22;
		}
yy110:
		yych = (char)*++*p;
		switch (yych) {
		case 'o':	goto yy128;
		default:	goto yy22;
		}
yy111:
		yych = (char)*++*p;
		switch (yych) {
		case 'n':	goto yy86;
		default:	goto yy22;
		}
yy112:
		yych = (char)*++*p;
		switch (yych) {
		case 'e':	goto yy86;
		default:	goto yy22;
		}
yy113:
		yych = (char)*++*p;
		switch (yych) {
		case 'e':	goto yy129;
		default:	goto yy22;
		}
yy114:
		yych = (char)*++*p;
		switch (yych) {
		case 's':	goto yy130;
		default:	goto yy22;
		}
yy115:
		yych = (char)*++*p;
		switch (yych) {
		case 'h':	goto yy131;
		default:	goto yy22;
		}
yy116:
		yych = (char)*++*p;
		switch (yych) {
		case 'e':	goto yy89;
		default:	goto yy22;
		}
yy117:
		yych = (char)*++*p;
		switch (yych) {
		case 't':	goto yy86;
		default:	goto yy22;
		}
yy118:
		yych = (char)*++*p;
		switch (yych) {
		case 'c':	goto yy49;
		default:	goto yy22;
		}
yy119:
		yych = (char)*++*p;
		switch (yych) {
		case 'd':	goto yy132;
		default:	goto yy22;
		}
yy120:
		yych = (char)*++*p;
		switch (yych) {
		case 'c':	goto yy133;
		default:	goto yy22;
		}
yy121:
		yych = (char)*++*p;
		switch (yych) {
		case 'o':	goto yy134;
		default:	goto yy22;
		}
yy122:
		yych = (char)*++*p;
		switch (yych) {
		case 'i':	goto yy135;
		default:	goto yy22;
		}
yy123:
		yych = (char)*++*p;
		switch (yych) {
		case 'd':	goto yy89;
		default:	goto yy22;
		}
yy124:
		yych = (char)*++*p;
		switch (yych) {
		case 's':	goto yy136;
		default:	goto yy22;
		}
yy125:
		yych = (char)*++*p;
		switch (yych) {
		case 'e':	goto yy137;
		default:	goto yy22;
		}
yy126:
		yych = (char)*++*p;
		switch (yych) {
		case 'g':	goto yy138;
		default:	goto yy22;
		}
yy127:
		yych = (char)*++*p;
		switch (yych) {
		case 'o':	goto yy139;
		default:	goto yy22;
		}
yy128:
		yych = (char)*++*p;
		switch (yych) {
		case 'w':	goto yy140;
		default:	goto yy22;
		}
yy129:
		yych = (char)*++*p;
		switch (yych) {
		case 'n':	goto yy83;
		default:	goto yy22;
		}
yy130:
		yych = (char)*++*p;
		switch (yych) {
		case 's':	goto yy143;
		default:	goto yy22;
		}
yy131:
		yych = (char)*++*p;
		switch (yych) {
		case 'a':	goto yy144;
		default:	goto yy22;
		}
yy132:
		yych = (char)*++*p;
		switch (yych) {
		case 'u':	goto yy145;
		default:	goto yy22;
		}
yy133:
		yych = (char)*++*p;
		switch (yych) {
		case 'k':	goto yy89;
		default:	goto yy22;
		}
yy134:
		yych = (char)*++*p;
		switch (yych) {
		case 'r':	goto yy89;
		default:	goto yy22;
		}
yy135:
		yych = (char)*++*p;
		switch (yych) {
		case 's':	goto yy146;
		default:	goto yy22;
		}
yy136:
		yych = (char)*++*p;
		switch (yych) {
		case 'e':	goto yy147;
		default:	goto yy22;
		}
yy137:
		yych = (char)*++*p;
		switch (yych) {
		case 's':	goto yy148;
		default:	goto yy22;
		}
yy138:
		yych = (char)*++*p;
		switch (yych) {
		case 'r':	goto yy149;
		default:	goto yy22;
		}
yy139:
		yych = (char)*++*p;
		switch (yych) {
		case 'r':	goto yy150;
		default:	goto yy22;
		}
yy140:
		yych = (char)*++*p;
		switch (yych) {
		case '\n':	goto yy142;
		default:	goto yy140;
		}
yy142:
#line 137 "spock_slaf.c"
		{ return PATHTRAVERSAL; }
#line 1008 "<stdout>"
yy143:
		yych = (char)*++*p;
		switch (yych) {
		case 'i':	goto yy151;
		default:	goto yy22;
		}
yy144:
		yych = (char)*++*p;
		switch (yych) {
		case 'r':	goto yy152;
		default:	goto yy22;
		}
yy145:
		yych = (char)*++*p;
		switch (yych) {
		case 'c':	goto yy112;
		default:	goto yy22;
		}
yy146:
		yych = (char)*++*p;
		switch (yych) {
		case 'h':	goto yy89;
		default:	goto yy22;
		}
yy147:
		yych = (char)*++*p;
		switch (yych) {
		case 'o':	goto yy153;
		default:	goto yy22;
		}
yy148:
		yych = (char)*++*p;
		switch (yych) {
		case 'h':	goto yy154;
		default:	goto yy22;
		}
yy149:
		yych = (char)*++*p;
		switch (yych) {
		case 'e':	goto yy155;
		default:	goto yy22;
		}
yy150:
		yych = (char)*++*p;
		switch (yych) {
		case 'd':	goto yy140;
		default:	goto yy22;
		}
yy151:
		yych = (char)*++*p;
		switch (yych) {
		case 'o':	goto yy156;
		default:	goto yy22;
		}
yy152:
		yych = (char)*++*p;
		switch (yych) {
		case 'C':	goto yy157;
		default:	goto yy22;
		}
yy153:
		yych = (char)*++*p;
		switch (yych) {
		case 'v':	goto yy158;
		default:	goto yy22;
		}
yy154:
		yych = (char)*++*p;
		switch (yych) {
		case 'o':	goto yy159;
		default:	goto yy22;
		}
yy155:
		yych = (char)*++*p;
		switch (yych) {
		case 's':	goto yy160;
		default:	goto yy22;
		}
yy156:
		yych = (char)*++*p;
		switch (yych) {
		case 'n':	goto yy89;
		default:	goto yy22;
		}
yy157:
		yych = (char)*++*p;
		switch (yych) {
		case 'o':	goto yy161;
		default:	goto yy22;
		}
yy158:
		yych = (char)*++*p;
		switch (yych) {
		case 'e':	goto yy134;
		default:	goto yy22;
		}
yy159:
		yych = (char)*++*p;
		switch (yych) {
		case 'w':	goto yy89;
		default:	goto yy22;
		}
yy160:
		yych = (char)*++*p;
		switch (yych) {
		case 's':	goto yy89;
		default:	goto yy22;
		}
yy161:
		yych = (char)*++*p;
		switch (yych) {
		case 'd':	goto yy116;
		default:	goto yy22;
		}
	}
#line 140 "spock_slaf.c"

    }
}


/* #times substr appears in s, no overlaps */
int 
spock_counter_matchs(const char *s, const char *substr)
{
    int n = 0;
    const char *p = s;

    size_t lenSubstr = strlen(substr);

	    while (*p) 
	    {
	        if (memcmp(p, substr, lenSubstr) == 0) 
	        {
	            ++n;
	            p += lenSubstr;
	        } else 
	            ++p;
	    }

    return n;
}


int 
spock_score_sqli(char *input)
{
	int total_list = 0;
	int score = 0, i = 0;
	
	const char *list[] = 
	{
		"insert","union","where","sleep","delete","mapreduce","timeout","@version","db.injection","/**/"
	};

	total_list = sizeof(list) / sizeof(list[0]);

		while(i!=total_list)
		{
			score+=spock_counter_matchs(input,list[i]);
			i++;
			if(SPOCK_SCORE<=score)
				return score;
		}

	return score;
}

int 
spock_score_pathtraversal(char *input)
{
	int total_list = 0;
	int score = 0, i = 0;
	const char *list[] = 
	{
		"..","\\\\","//","...","shadow","etc","password"
	};

	total_list = sizeof(list) / sizeof(list[0]);

		while(i!=total_list)
		{
			score+=spock_counter_matchs(input,list[i]);
			i++;
				if(SPOCK_SCORE<=score)
					return score;
		}

	return score;
}

int 
spock_score_xss(char *input)
{
	int total_list = 0;
	int score = 0, i = 0;
	const char *list[] = 
	{
		"eval","script","javascript","document","cookie","onstart","onerror","onpageshow","onprogress","alert","onclick","onmouseover","onfinish","fromChar","iframe"
	};

	total_list = sizeof(list) / sizeof(list[0]);

		while(i!=total_list)
		{
			score+=spock_counter_matchs(input,list[i]);
			i++;
				if(SPOCK_SCORE<=score)
					return score;
		}

	return score;
}


int
spock_dfa_check(char *input)
{

    char *last = input;


		switch (spock_dfa_filter(&input, &last)) 
		{
				case SQLI:
				return 1;
				break;

				case XSS:
				return 2;
				break;

				case PATHTRAVERSAL:
				return 3;
				break;
				  
				case FILTER_END:
				return 0;	
				break;
		}

	return 0;

}


// jack the ripper function 
// func to split request in chunks, util because a lot functions cannot match request buffer in full mode
bool 
spock_check (char * input)
{
	int option = 0;
	int score=0;


		option = spock_dfa_check(input);

				switch (option)
				{

						case 1:
						score=spock_score_sqli(input);
							if(score >= SPOCK_SCORE)
							{
		        					spock_write_log("Attack type: SQl injection\n");
								return true;
							}
					    	break;

						case 2:
						score=spock_score_xss(input);
							if(score >= SPOCK_SCORE)
							{
		        					spock_write_log("Attack type: XSS\n");
								return true;
							}
					   	break;

						case 3:
						score=spock_score_pathtraversal(input);
							if(score >= SPOCK_SCORE)
							{
		        					spock_write_log("Attack type: path traversal\n");
								return true;
							}
						break;
				  
				}
				
		
		



	return false;

}


// Deterministic Finite Automata to check if letter exist between a-z or A-Z
// generated by flex+bison
int 
spock_test_letter(char p)
{
	unsigned char yych;

	yych = p;
	switch (yych) 
	{
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'G':
			case 'H':
			case 'I':
			case 'J':
			case 'K':
			case 'L':
			case 'M':
			case 'N':
			case 'O':
			case 'P':
			case 'Q':
			case 'R':
			case 'S':
			case 'T':
			case 'U':
			case 'V':
			case 'W':
			case 'X':
			case 'Y':
			case 'Z':
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':
			case 'g':
			case 'h':
			case 'i':
			case 'j':
			case 'k':
			case 'l':
			case 'm':
			case 'n':
			case 'o':
			case 'p':
			case 'q':
			case 'r':
			case 's':
			case 't':
			case 'u':
			case 'v':
			case 'w':
			case 'x':
			case 'y':
			case 'z':	
				++p;
				return 0;
		default:	
				return 1; 
	}   

}

void 
_CONSTRUCTOR hook_init(void) 
{
	SPOCK_LOAD_CALL(spock_ctx.SSL_read, "SSL_read");
	SPOCK_LOAD_CALL(spock_ctx.SSL_get_rfd, "SSL_get_rfd");
	SPOCK_LOAD_CALL(spock_ctx.SSL_get_wfd, "SSL_get_wfd");
}


void 
_DESTRUCTOR hook_end(void) 
{
	SPOCK_DEBUG("end Spock SLAF");
}



static void *
spock_xmalloc_fatal(size_t size) 
{

	SPOCK_DEBUG("\n Memory FAILURE...\n size dbg: %zu\n",size);

	exit(0);
}


void *
spock_xmalloc (size_t size) 
{
	void *ptr = malloc (size);

		if (ptr == NULL) 
			return spock_xmalloc_fatal(size);

	return ptr;
}


void *
spock_xrealloc(void *ptr, size_t size)
{
	ptr = realloc(ptr, size);

		if (!ptr) 
		{
			SPOCK_DEBUG("realloc failed: %s", strerror(errno));
			exit(0);
		}
	return ptr;
}


// Fork of OpenBSD's function
/*
 * This is sqrt(SIZE_MAX+1), as s1*s2 <= SIZE_MAX
 * if both s1 < MUL_NO_OVERFLOW and s2 < MUL_NO_OVERFLOW
 */
#define SPOCK_MUL_NO_OVERFLOW	((size_t)1 << (sizeof(size_t) * 4))

void *
spock_reallocarray(void *optr, size_t nmemb, size_t size)
{
		if ((nmemb >= SPOCK_MUL_NO_OVERFLOW || size >= SPOCK_MUL_NO_OVERFLOW) &&
		    nmemb > 0 && SIZE_MAX / nmemb < size) 
		{
			errno = ENOMEM;
			return NULL;
		}
	return spock_xrealloc(optr, size * nmemb);
}

// Fork of OpenBSD's function
void *
spock_xmallocarray(size_t num, size_t size)
{
	void *result = spock_reallocarray(NULL, num, size);

        if (!result) 
        {
            SPOCK_DEBUG("reallocarray failed: %s", strerror(errno));
            exit(0);
        }

	return result;
}


char *
all2lowcase(char *str) 
{
	char *str_new=spock_xmallocarray(sizeof(char),strlen(str)+1);
	int i=0;
	
		while(*str != '\0')
		{
			// Deterministic Finite Automata to check letter and case 
				if(!spock_test_letter( *str ) )
				{
					*(str_new+i)=*str | 0x20;	
					i++;
				} else {
					*(str_new+i)=*str;
					i++;
				}


			str++;	
		}


	return str_new;

}


char *
spock_get_ip_str(struct sockaddr *sa, char *s, size_t maxlen)
{
	    switch(sa->sa_family) 
	    {
	        case AF_INET:
	            inet_ntop(AF_INET, &(((struct sockaddr_in *)sa)->sin_addr),
	                    s, maxlen);
	            break;

	        case AF_INET6:
	            inet_ntop(AF_INET6, &(((struct sockaddr_in6 *)sa)->sin6_addr),
	                    s, maxlen);
	            break;

	        default:
	            strncpy(s, "Unknown AF", maxlen);
	            return NULL;
	    }

    return s;
}

bool 
spock_is_request(char *ptr)
{
		if(ptr == NULL)
			return false;

		if(ptr[0]==' ')
			return false;

		if(ptr[1]==' ')
			return false;

		if(strnlen(ptr,12) < 10)
			return false;

	// So don't use strcmp() or strncmp() at this point. These functions are not thread-safe. Keep it like this:
	// is GET ?
	 	if(ptr[0]=='G' && ptr[1]=='E' && ptr[2]=='T')
			return true;

	// is POST ?
	 	if(ptr[0]=='P' && ptr[1]=='O' && ptr[2]=='S' && ptr[3]=='T')
			return true;

	// is PUT ?
	 	if(ptr[0]=='P' && ptr[1]=='U' && ptr[2]=='T')
			return true;

	// is DELETE?
	 	if(ptr[0]=='D' && ptr[1]=='E' && ptr[2]=='L' && ptr[3]=='E' && ptr[4]=='T' && ptr[5]=='E')
			return true;

	return false;
}

/*-strnstr() function
 * Copyright (c) 2001 Mike Barcroft <mike@FreeBSD.org>
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Chris Torek.*/
char *spock_strnstr(const char *s, const char *find, size_t slen)
{
	char c, sc;
	size_t len;

		if ((c = *find++) != '\0') 
		{
			len = strlen(find);

				do {
					do {
						if (slen-- < 1 || (sc = *s++) == '\0')
							return (NULL);
					} while (sc != c);
					if (len > slen)
						return (NULL);
				} while (strncmp(s, find, len) != 0);

			s--;
		}

	return ((char *)s);
}



bool spock_check_block(char *input, int num)
{
	int total_list = 0, total_shellcodes = 0, i = 0;

// use  this point for your custom list of shellcode to block.

#if UINTPTR_MAX == 0xffffffffffffffff
	const char *custom_shellcode[] = 
	{
		"\\x48\\x31\\xc0",                    // xor    rax,rax  X64 LINUX
		"\\x48\\x31\\xdb",                    // xor    rbx,rbx  X64 LINUX
	    	"\\x48\\x31\\xff",                    // xor    rdi,rdi  X64 LINUX
	    	"\\x48\\x31\\xf6",                    // xor    rsi,rsi  X64 LINUX
	    	"\\x48\\x31\\xd2",                    // xor    rdx,rdx  X64 LINUX
	    	"\\x48\\x89\\xe6",                    // mov    rsp,rsi  x64 LINUX 
	    	"\\x48\\x89\\xe7"                    // mov    rsp,rdi  x64 LINUX
	};
#elif UINTPTR_MAX == 0xffffffff	
	const char *custom_shellcode[] = 
	{
		"\\x31\\xc0",                         // xor    eax,eax  x32 LINUX
	    	"\\x31\\xc9",                         // xor    ecx,ecx  X32 LINUX
	    	"\\x31\\xdb",                         // xor    ebx,ebx  x32 LINUX
	    	"\\x31\\xd2",                         // xor    edx,edx  X32 LINUX
	    	"\\x89\\xe1",                         // mov    esp,ecx  x32 LINUX
	    	"\\x89\\xe3"                         // mov    esp,ebx  X32 LINUX
	};
#endif
	// ARM, MIPS in the future -- TODO


// generic payloads to block

	const char *list[] = 
	{
		"\\x90\\x90", // block NOP
		"\\x00\\x00", // nullbyte
		"\\xcd\\x80", // int $0x80 
		"\\xff\\xff",
		"/usr/bin",
		"%s%s%s%s",  // format string...
		"%u%u%u",
		"%x%x%x",
		"%d%d%d",
		"%2e%2e%2f%2e%2e%2f",
		"%252e%252e%252f",
		"%c0%ae",
		"%uff0e%uff0e",
		"0x80000000", // integer overflow maybe
		"0xffffffff",
		"<!--#echo var=",
		"<!--#exec cmd=",
		"autofillupload", // XXE
		"entity xxe",
		"///"
	};

    // prepare context filter
	char *prepared_input=all2lowcase(input);

	total_list = sizeof(list) / sizeof(list[0]);
	total_shellcodes = sizeof(custom_shellcode) / sizeof(custom_shellcode[0]);

	// Test SQL injection/ path traversal/ XSS following  using taint analysis + score based
		if (spock_check(prepared_input)==true)
		{
				free(prepared_input);
				prepared_input=NULL;
				return true;
		}

		while(i!=total_shellcodes)
		{
			if(spock_strnstr(prepared_input, custom_shellcode[i],num))
			{
				free(prepared_input);
				prepared_input=NULL;
				spock_write_log("Attack type: Buffer overflow\n");
				return true;
			}
			i++;
		}

	i = 0;

		while(i!=total_list)
		{
			if(spock_strnstr(prepared_input, list[i],num))
			{

				free(prepared_input);
				prepared_input=NULL;
				spock_write_log("Attack type: Anomaly\n");
				return true;
			}
			i++;
		}


	free(prepared_input);
	return false;
}



bool spock_detect_anomaly( int fd, void *buf, int num) 
{
	struct sockaddr addr;
	socklen_t addrlen = sizeof(struct sockaddr);


		if (getpeername(fd, &addr, &addrlen) < 0) 
		{
			SPOCK_DEBUG("getpeername error\n");
			exit(0);
		}

		if(SPOCK_BUGVIEW==1)
			printf("\n%s---> SPOCK DEBUG MODE <-========\n%s\n=======-> end DEBUG MODE\n%s",CYAN,(char *)buf,LAST);

    	if(SPOCK_ONLY_HTTP==1)
    	{
    		if(spock_is_request((char *)buf)==false)
    			return false;
    	}


		if(spock_check_block((char *)buf,num)==true)
		{
			int lenmax=(num+128+128)*sizeof(char);
			char *attacker_ip=spock_xmallocarray(129,sizeof(char));
			char *log_line=spock_xmallocarray(lenmax,sizeof(char));
			time_t rawtime = time(NULL);
			struct tm *ptm = localtime(&rawtime);

			spock_burn_mem(attacker_ip,0,128); // save one byte for canary, if you compile with full hardening argvs
			spock_get_ip_str(&addr,attacker_ip,128);	
			spock_burn_mem(log_line,0,lenmax-1);
	 		snprintf(log_line,lenmax-1,"Attacker IP: %s\ndatetime: %02d:%02d:%02d\n===\n%s\n===\n",attacker_ip,ptm->tm_hour,ptm->tm_min, ptm->tm_sec,(char *)buf);

				if(SPOCK_BUGVIEW==1)
					printf("\n%s---> SPOCK DEBUG MODE <-========\n%s\n=======-> end DEBUG MODE\n%s",RED,log_line,LAST);
			
			// write log
	        	spock_write_log(log_line);

	        	// free HEAP 
			free(attacker_ip);
			free(log_line);
			attacker_ip=NULL;
			log_line=NULL;

	        return true;
		}


	return false;
}


int 
SSL_read(void *ssl, void *buf, int num) 
{
	int fd, ret;
	ret = spock_ctx.SSL_read(ssl, buf, num);

		if (ssl != NULL && buf != NULL && ret > 0) 
		{
			fd = spock_ctx.SSL_get_rfd(ssl);

			if (fd < 0) 
			{
				fprintf(stderr, "SSL_get_rfd error\n");
				exit(EXIT_FAILURE);
			}

			if(spock_detect_anomaly(fd, buf, ret)==true)
			{
				// SSL_free(ssl); it's a good try if you detect any memory leak
				return 0;
			}
		}

	return ret;
}


